

# 数值

### 整数和浮点数

js中所有数字以64位浮点数储存，整数也是如此，这意味着1与1.0等值

```javascript
console.log(1==1.0)
//true

```

但是浮点数是有限二进制存储，不是完全精确的，如下的比较要注意

```javascript
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false
```

### 数值范围

64位浮点数中有11位属于指数部分，最大指数位2047

分出一半表示负数，则 JavaScript 能够表示的数值范围为$2^{1024}$到$2^{-1023}$（开区间）

#### 溢出

```javascript
Math.pow(2,1024)
//Infinity

Math.pow(2, -1075) // 0
```

#### 获得最大值和最小值

```javascript
Number.MAX_VALUE
Number.MIN_VALUE
```

#### 正0和负0

绝大部分场合两个0都是一样的

```
-0 === +0 // true
0 === -0 // true
0 === +0 // true
```

只有当其作为分母的时候，返回的值是不同的

```javascript
(1 / +0) === (1 / -0) // false
```

#### NaN

非数

主要出现在字符串解析成数字时出错的场合

```javascript
5-'x'//NaN
```

数学运算越界

```javascript
Math.acos(2) // NaN
Math.log(-1) // NaN
Math.sqrt(-1) // NaN
0/0
```

NaN是特殊数值，仍然是Number

```javascript
typeof NaN // 'number'
```

##### 运算规则

```js
NaN==NaN//false
Boolean(NaN)//false
NaN + 32 // NaN
NaN - 32 // NaN
NaN * 32 // NaN
NaN / 32 // NaN
```

#### 与数值相关的全局方法

#### parseInt()

将字符转化为整数

如果参数不是字符串，则会把其先转换为字符串再转换为int

```js
parseInt('123') // 123
parseInt('   81') // 81  忽视空格

parseInt(1.23) // 1
// 等同于
parseInt('1.23') // 1


//字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分
parseInt('8a') // 8
parseInt('12**') // 12
parseInt('12.34') // 12 并不是四舍五入
parseInt('15e2') // 15
parseInt('15px') // 15

//如果第一个字符不能转换为数字，则返回NaN。正负号除外
parseInt('abc') // NaN
parseInt('.3') // NaN
parseInt('') // NaN
parseInt('+') // NaN
parseInt('+1') // 1

//如果字符串以0x或0X开头，则该函数会将其解析为16进制数
parseInt('0X10')//16

//如果字符串以0开头，将其按照10进制解析。
parseInt('011') // 11


```

#### parseFloat()

将字符串转换为浮点型

```js
parseFloat('3.14') // 3.14
//如果字符串符合科学计数法，则会进行相应的转换。

parseFloat('314e-2') // 3.14
parseFloat('0.0314E+2') // 3.14
//如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。

parseFloat('3.14more non-digit characters') // 3.14
parseFloat方法会自动过滤字符串前导的空格。

parseFloat('\t\v\r12.34\n ') // 12.34
//如果参数不是字符串，则会先转为字符串再转换。

parseFloat([1.23]) // 1.23
// 等同于
parseFloat(String([1.23])) // 1.23
//如果字符串的第一个字符不能转化为浮点数，则返回NaN。

parseFloat([]) // NaN
parseFloat('FF2') // NaN
parseFloat('') // NaN
//上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。

//这些特点使得parseFloat的转换结果不同于Number函数。

parseFloat(true)  // NaN
Number(true) // 1

parseFloat(null) // NaN
Number(null) // 0

parseFloat('') // NaN
Number('') // 0

parseFloat('123.45#') // 123.45
Number('123.45#') // NaN
```

#### isNaN()

判断Number变量是否为NaN

如果不是Number类，则会被先转化为成Number,这意味着返回结果为true时并不一定输入的是NaN，建议使用前判断一下类型

```js
isNaN(NaN) // true
isNaN(123) // false


isNaN('Hello') // true
// 相当于
isNaN(Number('Hello')) // true Number('hello')是NaN

isNaN({}) // true
// 等同于
isNaN(Number({})) // true

isNaN(['xzy']) // true
// 等同于
isNaN(Number(['xzy'])) // true
```

#### isFinite()

```js
isFinite(Infinity) // false
isFinite(-Infinity) // false
isFinite(NaN) // false
isFinite(undefined) // false
isFinite(null) // true
isFinite(-1) // true
```

# 字符串

### 概述

#### 多行字符串

```js
a='1
2
3';//报错


//正确写法,在行末尾加上\
b='1\
2\
3';
```

#### 字符数组

字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。

```js
var s = 'hello';
s[0] // "h"
s[1] // "e"
s[4] // "o"

// 直接对字符串使用方括号运算符
'hello'[1] // "e"
```

如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回`undefined`。

```js
'abc'[3] // undefined
'abc'[-1] // undefined
'abc'['x'] // undefined
```

字符串不可修改

```js
var s='123456'
delete s[1]
s//123456

s[1]=1
s//123456
```

#### length

返回字符串长度

```js
var s = 'hello';
s.length // 5

s.length = 3;
s.length // 5

s.length = 7;
s.length // 5
```

# 对象

### 概述

对象是一组键值对集合，具有无序性

```js
var obj={
    foo:'hello',
    bar:'hello'
};
//大括号定义了一个对象，他被复制给了obj变量
//foo是键名  hello是键值

```

键名是字符型，键值是任意类型

如果一个键名的属性的值为函数，则这个属性可以成为方法

```js
var obj={
p:function(x){
return x*2；
}
}；
obj.p(1)
```

对象作为另一个对象的键值

```js
var o1={};
var o2={bar:'hello'};
o1.foo=o2
o1.foo.bar//o1的foo属性指向了o2,借此访问bar


```

属性可以动态创建，不必在对象声明时就指定

```js
var obj = {};
obj.foo = 123;
obj.foo // 123
```

#### 对象的引用

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

```js
var o1 = {};
var o2 = o1;

o1.a = 1;
o2.a // 1

o2.b = 2;
o1.b // 2
```

上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。

##### 取消引用

此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

```javascript
var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}
```

上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。



这种引用只局限于对象，如果两个变量指向同一个原始类型的值，那么变量并不共享空间

```js
var x = 1;
var y = x;

x = 2;
y // 1
```

### 属性操作

#### 属性读取

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```js
var obj = {
  p: 'Hello World'
};

obj.p // "Hello World"
obj['p'] // "Hello World"
```

#### 属性的查看

```js
var obj={
key1:1,
key2:2
};
Object.keys(obj);// ['key1', 'key2']
```

#### 属性的删除

`delete`命令用于删除对象的属性，删除成功后返回`true`。

```
var obj = { p: 1 };
Object.keys(obj) // ["p"]

delete obj.p // true
obj.p // undefined
Object.keys(obj) // []
```

上面代码中，`delete`命令删除对象`obj`的`p`属性。删除后，再读取`p`属性就会返回`undefined`，而且`Object.keys`方法的返回值也不再包括该属性。

注意，删除一个不存在的属性，`delete`不报错，而且返回`true`。

```
var obj = {};
delete obj.p // true
```

#### 判断属性是否存在

```js
var obj={p:1};
'p' in obj//true
'toString' in obj//true，继承属性

```

`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象`obj`本身并没有`toString`属性，但是`in`运算符会返回`true`，因为这个属性是继承的。

可以利用hasOwnProperty判断

```js
var obj={}
if ('toString' in obj){
console.log(obj.hasOwnProperty('toString'))//false
}
```

#### 遍历

```js
var obj = {a: 1, b: 2, c: 3};

for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
// 键名： a
// 键值： 1
// 键名： b
// 键值： 2
// 键名： c
// 键值： 3

//没有打印出继承的属性
```

#### with

简化对象操作

```js
var obj={
    p1:1,
    p2:2
    
}
with (obj){
    p1=4;
    p2=5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;
```

```
with (对象) {
  语句;//该语句可以直接访问对象中的属性
}
```

注意，如果`with`区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

```js
var obj = {};
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1 // undefined
p1 // 4
```

上面代码中，对象`obj`并没有`p1`属性，对`p1`赋值等于创造了一个全局变量`p1`。正确的写法应该是，先定义对象`obj`的属性`p1`，然后在`with`区块内操作它。